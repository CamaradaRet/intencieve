java массивы, к какому типу относится, какие есть особенности можно ли создать 0 длинны, могут ли расширяться

В языке программирования Java массивы являются объектами, создаются динамически и могут быть присвоены переменным типа Object. Все методы класса Object могут быть вызваны для массива.
Объект array содержит ряд переменных. 

Количество переменных может быть равно нулю, и в этом случае массив называется пустым. 

Переменные, содержащиеся в массиве, не имеют имен; вместо этого на них ссылаются выражения доступа к массиву, которые используют неотрицательные целочисленные значения индекса. 
Эти переменные называются компонентами массива. Если массив имеет n компонентов, мы говорим, что n - это длина массива; ссылки на компоненты массива выполняются с использованием целых индексов от 0 до n - 1 включительно.
Все компоненты массива имеют один и тот же тип, называемый типом компонента массива. Если тип компонента массива равен T, то записывается тип самого массива T[].
Тип компонента массива сам по себе может быть типом массива. Компоненты такого массива могут содержать ссылки на подмассивы. Если, начиная с любого типа массива, рассматривать тип его компонента, а затем (если это также тип массива) тип компонента этого типа и так далее, в конечном итоге необходимо достичь типа компонента, который не является типом массива; это называется типом элемента исходного массива, а компоненты на этом уровне структуры данных называются элементами исходного массива.
Существуют некоторые ситуации, в которых элементом массива может быть массив: если тип элемента - Object or Cloneable или java.io.Serializable, то некоторые или все элементы могут быть массивами, поскольку любой объект массива может быть присвоен любой переменной из этих типов.
Тип массива записывается как название типа элемента, за которым следует некоторое количество пустых пар квадратных скобок []. Количество пар скобок указывает глубину вложенности массива.
Каждая пара скобок в типе массива может быть снабжена аннотациями типа. Аннотация применяется к паре скобок (или многоточию в объявлении параметра переменной arity), которая следует за ней.
Тип элемента массива может быть любым, будь то примитивный или ссылочный. В частности:
•	Допускаются массивы с типом интерфейса в качестве типа элемента.
Элемент такого массива может иметь в качестве своего значения нулевую ссылку или экземпляр любого типа, реализующий интерфейс.
•	Допускаются массивы с abstract типом класса в качестве типа элемента.
Элемент такого массива может иметь в качестве своего значения нулевую ссылку или экземпляр любого подкласса abstract класса, который не является им самим abstract.
Длина массива не является частью его типа.
После создания объекта array его длина никогда не меняется. Чтобы переменная array ссылалась на массив другой длины, переменной должна быть присвоена ссылка на другой массив.
Одна переменная типа array может содержать ссылки на массивы разной длины, поскольку длина массива не является частью его типа.
Если переменная массива v имеет тип A[], где A - ссылочный тип, то v может содержать ссылку на экземпляр любого типа массива B[], при условии, что B может быть присвоен A. Это может привести к исключению во время выполнения при более позднем назначении.

Если тип присваиваемого значения несовместим с присваиванием с типом компонента, выбрасывается исключение ArrayStoreException.
Массив создается с помощью выражения создания массива или инициализатора массива.
Выражение для создания массива определяет тип элемента, количество уровней вложенных массивов и длину массива по крайней мере для одного из уровней вложенности. Длина массива доступна как final переменная экземпляра length.
Инициализатор массива создает массив и предоставляет начальные значения для всех его компонентов.
Доступ к компоненту массива осуществляется с помощью выражения доступа к массиву, которое состоит из выражения, значением которого является ссылка на массив, за которой следует выражение индексации, заключенное в квадратные скобки [ и ], как в A[i].
Все массивы имеют исходное значение. Массив длиной n может быть проиндексирован целыми числами от 0 до n -1.
Массивы должны быть проиндексированы по int значениям; short, byte или char значения также могут использоваться в качестве индексных значений, поскольку они подвергаются унарному числовому продвижению и становятся int значениями.
Попытка получить доступ к компоненту массива с long значением индекса приводит к ошибке времени компиляции.
Все обращения к массиву проверяются во время выполнения; попытка использовать индекс, который меньше нуля или больше или равен длине массива, приводит к выдаче исключения ArrayIndexOutOfBoundsException.
Инициализатор массива записывается в виде списка выражений, разделенных запятыми, заключенного в фигурные скобки { и }.
Запятая в конце может появляться после последнего выражения в инициализаторе массива и игнорироваться.
Каждый инициализатор переменной должен быть совместим с присваиванием и соответствовать компонентному типу массива, в противном случае возникает ошибка времени компиляции.
Это ошибка времени компиляции, если тип компонента инициализируемого массива не поддается повторной проверке.
Длина создаваемого массива равна количеству инициализаторов переменных, непосредственно заключенных в фигурные скобки инициализатора массива. Место выделяется для нового массива такой длины. Если для выделения массива недостаточно места, вычисление инициализатора массива внезапно завершается выдачей исключения OutOfMemoryError. В противном случае создается одномерный массив указанной длины, и каждый компонент массива инициализируется значением по умолчанию.
Инициализаторы переменных, непосредственно заключенные в фигурные скобки инициализатора массива, затем выполняются слева направо в том текстовом порядке, в каком они встречаются в исходном коде. Инициализатор n-й переменной задает значение n-1-го компонента массива. Если выполнение инициализатора переменной завершается внезапно, то выполнение инициализатора массива завершается внезапно по той же причине. Если все выражения инициализатора переменной завершаются нормально, инициализатор массива завершается нормально со значением вновь инициализированного массива.
Если тип компонента является типом массива, то инициализатор переменной, задающий компонент, сам может быть инициализатором массива; то есть инициализаторы массива могут быть вложенными. В этом случае выполнение инициализатора вложенного массива создает и инициализирует объект массива путем рекурсивного применения описанного выше алгоритма и присваивает его компоненту.
Все элементы типа массива являются следующими:

•	public final Поле length, которое содержит количество компонентов массива. length может быть положительным или нулевым.

•	public Метод clone, который переопределяет одноименный метод в классе Object и не выдает проверяемых исключений. Тип, возвращаемый clone методом типа массива T[], равен T[].
Клонирование многомерного массива является неглубоким, то есть создает только один новый массив. Подмассивы являются общими.

•	Все члены наследуются от класса Object; единственный метод Object, который не наследуется, - это его clone метод.

С каждым массивом связан Class объект, совместно используемый со всеми другими массивами с тем же типом компонента.
Хотя тип массива не является классом, Class объект каждого массива действует так, как если бы:

•	Прямым суперклассом каждого типа массива является Object.

•	Каждый тип массива реализует интерфейсы Cloneable и java.io.Serializable.


Примеры объявления, инициализации и блока инициализации массива:

Объявление:

    int[] a[]; 
    int[] a, f[]; 
    int[] a[], f[];            такие выражения не создают массив, но лишь создают ссылку,
    int[] a;                   для создания массива необходимо записать следующее выражение:
    int a[];                  для примитивных типов int[] a = new int[10]
    int a, f[], b[][];       для ссылочных типов Object[] o = new Object[10];

блок инициализации: 

    int[] a = {1, 3, 8, 12}; 
создался массив размером на 4 элемента, который не может быть изменён; индексация начинается с 0, т.е. для обращения к первому элементу массивa используется синтаксис:
     
    int b = a[0];

инициализация без блока инициализации:

    int[] a = new int[4];
    a[0] = 1;
    a[1] = 3;
    a[2] = 8;
    a[3] = 12;

размерность массива должна быть указана при его объявлении, если массив многомерный то обязательно нужно указать размерность первого массива:

    int[] a = new int[0];
    int[][][] b = new int[11][][];

Ресурсы :
https://docs.oracle.com/javase/specs/jls/se18/html/jls-10.html 
